# databases
Практические по предмету базы данных
1) CHAR: представляет строку фиксированной длины.
Длина хранимой строки указывается в скобках, например, CHAR(10) - строка из десяти символов. И если в таблицу в данный столбец сохраняется строка из 6 символов (то есть меньше установленной длины в 10 символов), то строка дополняется 4 пробелами и в итоге все равно будет занимать 10 символов
Тип CHAR может хранить до 255 байт.
2) VARCHAR: представляет строку переменной длины.
Длина хранимой строки также указыватся в скобках, например, VARCHAR(10). Однако в отличие от CHAR хранимая строка будет занимать именно столько места, сколько необходимо. Например, если определенная длина в 10 символов, но в столбец сохраняется строка в 6 символов, то хранимая строка так и будет занимать 6 символов плюс дополнительный байт, который хранит длину строки.
Всего тип VARCHAR может хранить до 65535 байт.
Начиная с MySQL 5.6 типы CHAR и VARCHAR по умолчанию используют кодировку UTF-8, которая позволяет использовать до 3 байт для хранения символа в зависимости от языка ( для многих европейских языков по 1 байту на символ, для ряда восточно-европейских и ближневосточных - 2 байта, а для китайского, японского, корейского - по 3 байта на символ).
Ряд дополнительных типов данных представляют текст неопределенной длины:
3) TINYTEXT: представляет текст длиной до 255 байт.
4) TEXT: представляет текст длиной до 65 КБ.
5) MEDIUMTEXT: представляет текст длиной до 16 МБ
6) LONGTEXT: представляет текст длиной до 4 ГБ
Числовые типы:
7) TINYINT: представляет целые числа от -128 до 127, занимает 1 байт
8) BOOL: фактически не представляет отдельный тип, а является лишь псевдонимом для типа TINYINT(1) и может хранить два значения 0 и 1. Однако данный тип может также в качестве значения принимать встроенные константы TRUE (представляет число 1) и FALSE (предоставляет число 0).Также имеет псевдоним BOOLEAN.
9) TINYINT UNSIGNED: представляет целые числа от 0 до 255, занимает 1 байт
10) SMALLINT: представляет целые числа от -32768 до 32767, занимает 2 байтa
11) SMALLINT UNSIGNED: представляет целые числа от 0 до 65535, занимает 2 байтa
12) MEDIUMINT: представляет целые числа от -8388608 до 8388607, занимает 3 байта
13) MEDIUMINT UNSIGNED: представляет целые числа от 0 до 16777215, занимает 3 байта
14) INT: представляет целые числа от -2147483648 до 2147483647, занимает 4 байта
15) INT UNSIGNED: представляет целые числа от 0 до 4294967295, занимает 4 байта
16) BIGINT: представляет целые числа от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807, занимает 8 байт
17) BIGINT UNSIGNED: представляет целые числа от 0 до 18 446 744 073 709 551 615, занимает 8 байт
18) DECIMAL: хранит числа с фиксированной точностью. Данный тип может принимать два параметра precision и scale: DECIMAL(precision, scale).
Параметр precision представляет максимальное количество цифр, которые может хранить число. Это значение должно находиться в диапазоне от 1 до 65.
Параметр scale представляет максимальное количество цифр, которые может содержать число после запятой. Это значение должно находиться в диапазоне от 0 до значения параметра precision. По умолчанию оно равно 0.
# шпоргалки по базовым командам 
1) SELECT (от англ. select — «выбрать») — оператор запроса (DML/DQL) в языке SQL, возвращающий набор данных (выборку) из базы данных.
Оператор возвращает ноль или более строк. Список возвращаемых столбцов задается в части оператора, называемой предложением SELECT. Поскольку SQL является декларативным языком, запрос SELECT определяет лишь требования к возвращаемому набору данных, но не является точной инструкцией по их вычислению. СУБД транслирует запрос SELECT во внутренний план исполнения («query plan»), который может различаться даже для синтаксически одинаковых запросов и от конкретной СУБД.
2) WHERE - Зачастую необходимо извлекать не все данные из БД, а только те, которые соответствуют определенному условию. Для фильтрации данных в команде SELECT применяется оператор WHERE, после которого указывается условие:
"WHERE условие"
Если условие истинно, то строка попадает в результирующую выборку. В качестве можно использовать операции сравнения, которые сравнивают два выражения:
=: сравнение на равенство
!=: сравнение на неравенство
<>: сравнение на неравенство
<: меньше чем
>: больше чем
<=: меньше чем или равно
>=: больше чем или равно
К примеру, выберем всех товары, производителем которых является компания Samsung:
SELECT * FROM Products
WHERE Manufacturer = 'Samsung';
Стоит отметить, что для MySQL не важен регистр символов, и, к примеру, строка "Samsung" будет эквивалентна строке "SAMSUNG" или "samSunG".
3) And, Or - SQL условия AND и OR можно комбинировать для проверки нескольких условий в операторе SELECT, INSERT, UPDATE или DELETE
Синтаксис для условий AND и OR в SQL:
WHERE condition1
AND condition2
...
OR condition_n;
Параметры или аргументы:
condition1, condition2, ... condition_n
Условия, которые оцениваются, чтобы определить, будут ли выбраны записи.
SQL условия позволяют тестировать несколько условий.
Не забудьте порядок операций в скобках!
В этом примере у нас есть таблица suppliers со следующими данными:
supplier_id:	supplier_name:	    city:	              state:
100	          Yandex	            Moscow	            Moscow
200	          Google	            Lansing             Michigan
300	          Oracle	            Redwood City        California
400	          Bing	              Redmond	            Washington
500	          Yahoo	              Sunnyvale	          Washington
600	          DuckDuckGo	        Paoli	              Pennsylvania
700	          Qwant	              Paris	Ile de        France
800	          Facebook	          Menlo Park          California
900	          Electronic Arts	    San  Francisco	    California
Введите следующий SQL оператор:
SELECT *
  FROM suppliers
 WHERE (state = 'California' AND supplier_id <> 900)
    OR (supplier_id = 100);
Будет выбрано 3 записи. Вот результаты, которые вы получите:
upplier_id:	  supplier_name:	    city:               state:
100	          Yandex	            Moscow	            Moscow
300	          Oracle	            Redwood City	      California
800	          Facebook	          Menlo Park	        California
4) Order by
SQL оператор ORDER BY используется для сортировки записей в наборе результатов запроса SELECT.
Синтаксис
Синтаксис для оператора ORDER BY в SQL:
SELECT expressions
  FROM tables
[WHERE conditions]
 ORDER BY expression [ ASC | DESC ];
Параметры или аргумент:
expressions
 Столбцы или расчеты, которые вы хотите получить
tables
 Таблицы, из которых вы хотите получить записи. В предложении FROM должна быть указана хотя бы одна таблица
WHERE conditions
 Необязательный. Условия, которые должны быть выполнены для записей, которые будут выбраны
ASC
 Необязательный. ASC сортирует результирующий набор в порядке возрастания по expressions. Это поведение по умолчанию, если модификатор не указан.
DESC
 Необязательный. DESC сортирует результирующий набор в порядке убывания по expressions
Примечание: если модификатор ASC или DESC не указан в предложении ORDER BY, результаты будут отсортированы по expressions в порядке возрастания. Это эквивалентно ORDER BY expressions ASC
Пример - сортировка результатов по возрастанию:
Чтобы отсортировать результаты в порядке возрастания, вы можете указать атрибут ASC. Если после поля в предложении ORDER BY не указано значение (ASC или DESC), порядок сортировки по умолчанию будет соответствовать возрастающему.
для этого ведите следующий SQL оператор
SELECT *
  FROM customers
 ORDER BY last_name;
5) LIMIT и OFFSET
Оператор LIMIT позволяет извлечь определенное количество строк:
SELECT * FROM Products
ORDER BY ProductName
LIMIT 4;
Оператор OFFSET позволяет указать, с какой строки надо начинать выборку. Например, выберем 3 строки, начиная со 2-й:
SELECT * FROM Products
ORDER BY ProductName
LIMIT 3 OFFSET 2;
Если нам надо выбрать вообще все строки, начиная с какой-то определенной, то оператор LIMIT можно опустить:
SELECT * FROM Products
ORDER BY ProductName
OFFSET 2;
Либо после LIMIT указать ключевое слово ALL:
SELECT * FROM Products
ORDER BY ProductName
LIMIT ALL OFFSET 2;
6) UPDATE
Команда UPDATE применяется для обновления уже имеющихся строк. Она имеет следующий формальный синтаксис:
UPDATE имя_таблицы
SET столбец1 = значение1, столбец2 = значение2, ... столбецN = значениеN
[WHERE условие_обновления]
Например, увеличим у всех товаров цену на 3000:
UPDATE Products
SET Price = Price + 3000;
Однако при выполнении данного запроса в MySQL Workbench мы можем столкнуться с ошибкой. Ошибка говорит о том, что мы находимся в безопасном режиме. И чтобы его отключить, в MySQL Workbench надо перейти в меню Edit -> Preferences и в открывшемся окне перейти к пункту SQL Editor
В открывшейся вкладке в самом низу надо снять флажок с поля "Safe Updates (reject UPDATEs and DELETEs with no restrictions)" и затем сохранить изменения, нажав на кнопку OK. После этого надо переподключиться к серверу.
7) set
Множество (set) представляют еще один вид набора, который хранит только уникальные элементы. Для определения множества используются фигурные скобки, в которых перечисляются элементы:
users = {"Tom", "Bob", "Alice", "Tom"}
print(users)    # {"Alice", "Bob", "Tom"}
братите внимание, что несмотря на то, что функция print вывела один раз элемент "Tom", хотя в определении множества этот элемент содержится два раза. Все потому что множество содержит только уникальные значения.
Также для определения множества может применяться функция set(), в которую передается список или кортеж элементов:
people = ["Mike", "Bill", "Ted"]
users = set(people)
print(users)    # {"Mike", "Bill", "Ted"}
Функцию set удобно применять для создания пустого множества:
users = set()
Для получения длины множества применяется встроенная функция len():
sers = {"Tom", "Bob", "Alice"}
print(len(users))       # 3
Для добавления одиночного элемента вызывается метод add():
users = set()
users.add("Sam")
print(users)
Удаление элементов:
Для удаления одного элемента вызывается метод remove(), в который передается удаляемый элемент. Но следует учитывать, что если такого элемента не окажется в множестве, то будет сгенерирована ошибка. Поэтому перед удалением следует проверять на наличие элемента с помощью оператора in:
users = {"Tom", "Bob", "Alice"}
user = "Tom"
if user in users: 
    users.remove(user)
print(users)    # {"Bob", "Alice"}
Также для удаления можно использовать метод discard(), который не будет генерировать исключения при отсутствии элемента:
users = {"Tom", "Bob", "Alice"}
users.discard("Tim")    # элемент "Tim" отсутствует, и метод ничего не делает
print(users)    #  {"Tom", "Bob", "Alice"}
users.discard("Tom")    # элемент "Tom" есть, и метод удаляет элемент
print(users)    #  {"Bob", "Alice"}
Для удаления всех элементов вызывается метод clear():
users.clear()
Перебор множества
Для перебора элементов можно использовать цикл for:
users = {"Tom", "Bob", "Alice"}
for user in users:
    print(user)
При переборе каждый элемент помещается в переменную user.
Операции с множествами
С помощью метода copy() можно скопировать содержимое одного множества в другую переменную:
users = {"Tom", "Bob", "Alice"}
students = users.copy()
print(students)     # {"Tom", "Bob", "Alice"}
Объединение множеств
Метод union() объединяет два множества и возвращает новое множество:
users = {"Tom", "Bob", "Alice"}
users2 = {"Sam", "Kate", "Bob"}
users3 = users.union(users2)
print(users3)   # {"Bob", "Alice", "Sam", "Kate", "Tom"}
Вместо метода union() мы могли бы использовать операцию логического сложения - |:
users = {"Tom", "Bob", "Alice"}
users2 = {"Sam", "Kate", "Bob"}
print(users | users2)   # {"Bob", "Alice", "Sam", "Kate", "Tom"}
Пересечение множеств
Пересечение множеств позволяет получить только те элементы, которые есть одновременно в обоих множествах. Метод intersection() производит операцию пересечения множеств и возвращает новое множество:
users = {"Tom", "Bob", "Alice"}
users2 = {"Sam", "Kate", "Bob"}
users3 = users.intersection(users2)
print(users3)   # {"Bob"}
Вместо метода intersection мы могли бы использовать операцию логического умножения:
users = {"Tom", "Bob", "Alice"}
users2 = {"Sam", "Kate", "Bob"}
print(users & users2)   # {"Bob"}
В этом случае мы получили бы тот же результат.
Модификация метода - intersection_update() заменяет пересеченными элементами первое множество:
users = {"Tom", "Bob", "Alice"}
users2 = {"Sam", "Kate", "Bob"}
users.intersection_update(users2)
print(users)   # {"Bob"}
Разность множеств
Еще одна операция - разность множеств возвращает те элементы, которые есть в первом множестве, но отсутствуют во втором. Для получения разности множеств можно использовать метод difference или операцию вычитания:
users = {"Tom", "Bob", "Alice"}
users2 = {"Sam", "Kate", "Bob"}
users3 = users.difference(users2)
print(users3)           # {"Tom", "Alice"}
print(users - users2)   # {"Tom", "Alice"}
Отдельная разновидность разности множеств - симметрическая разность производится с помощью метода symmetric_difference() или с помощью операции ^. Она возвращает все элементы обоих множеств за исключением общих:
users = {"Tom", "Bob", "Alice"}
users2 = {"Sam", "Kate", "Bob"}
users3 = users.symmetric_difference(users2)
print(users3)   # {"Tom", "Alice", "Sam", "Kate"}
users4 = users ^ users2
print(users4)   # {"Tom", "Alice", "Sam", "Kate"}
Отношения между множествами
Метод issubset позволяет выяснить, является ли текущее множество подмножеством (то есть частью) другого множества:
users = {"Tom", "Bob", "Alice"}
superusers = {"Sam", "Tom", "Bob", "Alice", "Greg"}
print(users.issubset(superusers))   # True
print(superusers.issubset(users))   # False
Метод issuperset, наоборот, возвращает True, если текущее множество является надмножеством (то есть содержит) для другого множества:
users = {"Tom", "Bob", "Alice"}
superusers = {"Sam", "Tom", "Bob", "Alice", "Greg"}
print(users.issuperset(superusers))   # False
print(superusers.issuperset(users))   # True
frozen set
Тип frozen set является видом множеств, которое не может быть изменено. Для его создания используется функция frozenset:
users = frozenset({"Tom", "Bob", "Alice"})
В функцию frozenset передается набор элементов - список, кортеж, другое множество.
В такое множество мы не можем добавить новые элементы, как и удалить из него уже имеющиеся. Собственно поэтому frozen set поддерживает ограниченный набор операций:
len(s): возвращает длину множества
x in s: возвращает True, если элемент x присутствует в множестве s
x not in s: возвращает True, если элемент x отсутствует в множестве s
s.issubset(t): возвращает True, если t содержит множество s
s.issuperset(t): возвращает True, если t содержится в множестве s
s.union(t)
: возвращает объединение множеств s и t
s.intersection(t): возвращает пересечение множеств s и t
s.difference(t): возвращает разность множеств s и t
s.copy(): возвращает копию множества s
